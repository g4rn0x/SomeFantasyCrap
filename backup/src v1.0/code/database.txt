==DatabaseConnection.cpp==

#include "DatabaseConnection.h"
#include <QSqlError>
#include <QDebug>

DatabaseConnection::DatabaseConnection()
    : m_connected(false)
{
}

DatabaseConnection::~DatabaseConnection()
{
    if (m_connected) {
        m_database.close();
    }
}

bool DatabaseConnection::connectSQLite(const QString &databasePath)
{
    // Если уже подключены, закрываем старое соединение
    if (m_connected && m_database.isOpen()) {
        m_database.close();
        m_connected = false;
    }

    // Удаляем старое соединение если оно существует
    if (QSqlDatabase::contains(QSqlDatabase::defaultConnection)) {
        QSqlDatabase::removeDatabase(QSqlDatabase::defaultConnection);
    }

    m_database = QSqlDatabase::addDatabase("QSQLITE");
    m_database.setDatabaseName(databasePath);

    qDebug() << "Available SQL drivers:" << QSqlDatabase::drivers();

    if (!m_database.open()) {
        m_lastError = m_database.lastError().text();
        qCritical() << "SQLite connection failed:" << m_lastError;
        return false;
    }

    m_connected = true;
    qDebug() << "Connected to SQLite database:" << databasePath;
    return true;
}


bool DatabaseConnection::connect(const QString &host, const QString &database,
                                const QString &user, const QString &password, int port)
{
    if (m_connected) {
        return true;
    }

    m_database = QSqlDatabase::addDatabase("QMYSQL");
    m_database.setHostName(host);
    m_database.setDatabaseName(database);
    m_database.setUserName(user);
    m_database.setPassword(password);
    m_database.setPort(port);

    if (!m_database.open()) {
        m_lastError = m_database.lastError().text();
        qCritical() << "MySQL connection failed:" << m_lastError;
        return false;
    }

    m_connected = true;
    qDebug() << "Connected to MySQL database:" << database;
    return true;
}

bool DatabaseConnection::isConnected() const
{
    return m_connected && m_database.isOpen();
}

QSqlDatabase DatabaseConnection::getDatabase()
{
    return m_database;
}

QString DatabaseConnection::getLastError() const
{
    return m_lastError;
}

void DatabaseConnection::disconnect()
{
    if (m_connected) {
        QString connectionName = m_database.connectionName();
        m_database.close();
        m_connected = false;

        // Удаляем соединение из пула Qt
        if (QSqlDatabase::contains(connectionName)) {
            QSqlDatabase::removeDatabase(connectionName);
        }

        qDebug() << "Database disconnected";
    }
}


==DatabaseConnection.h==

#ifndef DATABASECONNECTION_H
#define DATABASECONNECTION_H

#include <QString>
#include <QSqlDatabase>

class DatabaseConnection
{
public:
    DatabaseConnection();
    ~DatabaseConnection();

    bool connectSQLite(const QString &databasePath);
    bool connect(const QString &host, const QString &database,
                const QString &user, const QString &password, int port = 3306);

    bool isConnected() const;
    QSqlDatabase getDatabase();
    QString getLastError() const;
    void disconnect();

private:
    QSqlDatabase m_database;
    bool m_connected;
    QString m_lastError;
};

#endif // DATABASECONNECTION_H


==DatabaseManager.cpp==

#include "DatabaseManager.h"
#include <QtSql/QSqlQuery>
#include <QtSql/QSqlError>
#include <QJsonDocument>
#include <QJsonArray>
#include <QDebug>
#include <QFile>
#include <QTextStream>
#include <QProcess>
#include <QCoreApplication>
#include "../core/Constants.h"
#include <QDir>

DatabaseManager::DatabaseManager()
    : m_connection(std::make_unique<DatabaseConnection>())
{
}

DatabaseManager::~DatabaseManager() = default;

bool DatabaseManager::connect()
{
    if (!m_connection->connectSQLite("maze_game.db")) {
        m_lastError = m_connection->getLastError();
        qCritical() << "Failed to connect to SQLite:" << m_lastError;
        return false;
    }

    if (!isDatabaseInitialized()) {
        qDebug() << "Database not initialized. Loading from SQL file...";

        QString baseDir = QCoreApplication::applicationDirPath();
        QString sqlPath = baseDir + "/game_database.sql";

        if (!loadSqlFile("game_database.sql")) {
            m_lastError = "Failed to load database from SQL file";
            return false;
        }

        qDebug() << "Database initialized successfully!";
    } else {
        qDebug() << "Database already initialized";
    }

    return true;
}




bool DatabaseManager::isConnected() const
{
    return m_connection->isConnected();
}

bool DatabaseManager::isDatabaseInitialized()
{
    QSqlQuery query(m_connection->getDatabase());

    if (!query.exec("SELECT name FROM sqlite_master WHERE type='table' AND name='locations'")) {
        qWarning() << "Failed to check database:" << query.lastError().text();
        return false;
    }

    if (query.next()) {
        QSqlQuery countQuery(m_connection->getDatabase());
        if (countQuery.exec("SELECT COUNT(*) FROM locations") && countQuery.next()) {
            int count = countQuery.value(0).toInt();
            qDebug() << "Found" << count << "locations in database";
            return count > 0;
        }
    }

    qDebug() << "Database is not initialized";
    return false;
}

bool DatabaseManager::loadSqlFile(const QString &filePath)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qCritical() << "Cannot open SQL file:" << filePath;
        qCritical() << "Current dir:" << QDir::currentPath();
        m_lastError = "Cannot open SQL file: " + filePath;
        return false;
    }

    QByteArray sqlData = file.readAll();
    file.close();

    QString sqlContent = QString::fromUtf8(sqlData);

    qDebug() << "SQL file loaded, size:" << sqlContent.length() << "bytes";

    // КРИТИЧНО: Принудительная замена AUTO_INCREMENT -> AUTOINCREMENT
    sqlContent.replace(QRegularExpression("AUTO_INCREMENT", QRegularExpression::CaseInsensitiveOption),
                      "AUTOINCREMENT");

    // Разбиваем на отдельные операторы вручную
    QStringList statements;
    QString currentStatement;
    bool inString = false;

    for (int i = 0; i < sqlContent.length(); i++) {
        QChar c = sqlContent[i];

        // Отслеживаем строки (чтобы не разбивать по ; внутри строк)
        if (c == '\'' && (i == 0 || sqlContent[i-1] != '\\')) {
            inString = !inString;
        }

        // Пропускаем комментарии --
        if (!inString && c == '-' && i + 1 < sqlContent.length() && sqlContent[i+1] == '-') {
            // Пропускаем до конца строки
            while (i < sqlContent.length() && sqlContent[i] != '\n') {
                i++;
            }
            continue;
        }

        currentStatement += c;

        // Разделяем по ; вне строк
        if (!inString && c == ';') {
            QString stmt = currentStatement.trimmed();
            if (!stmt.isEmpty() && !stmt.startsWith("--")) {
                statements.append(stmt);
            }
            currentStatement.clear();
        }
    }

    qDebug() << "Found" << statements.size() << "SQL statements";

    QSqlDatabase db = m_connection->getDatabase();

    if (!db.transaction()) {
        qWarning() << "Failed to start transaction:" << db.lastError().text();
    }

    QSqlQuery query(db);
    int successCount = 0;
    int failCount = 0;

    for (const QString &stmt : statements) {
        if (query.exec(stmt)) {
            successCount++;
            qDebug() << "✓ OK:" << stmt.left(60) + "...";
        } else {
            failCount++;
            qCritical() << "✗ FAIL:" << query.lastError().text();
            qCritical() << "Statement:" << stmt.left(150);
        }
    }

    if (!db.commit()) {
        qCritical() << "Failed to commit transaction:" << db.lastError().text();
        db.rollback();
        return false;
    }

    qDebug() << "SQL execution completed. Success:" << successCount << "Failed:" << failCount;

    return successCount > 0 && failCount == 0;
}



QVector<LocationData> DatabaseManager::loadLocations()
{
    QVector<LocationData> locations;

    QSqlQuery query(m_connection->getDatabase());
    query.prepare("SELECT id, name, theme, description FROM locations ORDER BY id");

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to load locations:" << m_lastError;
        return locations;
    }

    while (query.next()) {
        LocationData loc;
        loc.id = query.value(0).toInt();
        loc.name = query.value(1).toString();
        loc.theme = query.value(2).toString();
        loc.description = query.value(3).toString();
        locations.append(loc);
    }

    qDebug() << "Loaded" << locations.size() << "locations from database";
    return locations;
}

QVector<RiddleData> DatabaseManager::loadRiddles()
{
    QVector<RiddleData> riddles;

    QSqlQuery query(m_connection->getDatabase());
    query.prepare("SELECT id, question, answer, difficulty FROM riddles ORDER BY difficulty");

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to load riddles:" << m_lastError;
        return riddles;
    }

    while (query.next()) {
        RiddleData riddle;
        riddle.id = query.value(0).toInt();
        riddle.question = query.value(1).toString();
        riddle.answer = query.value(2).toString().toLower();
        riddle.difficulty = query.value(3).toInt();
        riddles.append(riddle);
    }

    qDebug() << "Loaded" << riddles.size() << "riddles from database";
    return riddles;
}

QVector<NoteData> DatabaseManager::loadNotes()
{
    QVector<NoteData> notes;

    QSqlQuery query(m_connection->getDatabase());
    query.prepare("SELECT id, content, location_id FROM notes ORDER BY id");

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to load notes:" << m_lastError;
        return notes;
    }

    while (query.next()) {
        NoteData note;
        note.id = query.value(0).toInt();
        note.content = query.value(1).toString();
        note.locationId = query.value(2).toInt();
        notes.append(note);
    }

    qDebug() << "Loaded" << notes.size() << "notes from database";
    return notes;
}

QVector<ItemData> DatabaseManager::loadItems()
{
    QVector<ItemData> items;

    QSqlQuery query(m_connection->getDatabase());
    query.prepare("SELECT id, type, name, description, rarity FROM items");

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to load items:" << m_lastError;
        return items;
    }

    while (query.next()) {
        ItemData item;
        item.id = query.value(0).toInt();
        QString typeStr = query.value(1).toString();
        item.type = (typeStr == "GOLD_KEY") ? ItemType::GOLD_KEY : ItemType::SILVER_KEY;
        item.name = query.value(2).toString();
        item.description = query.value(3).toString();

        QString rarityStr = query.value(4).toString();
        if (rarityStr == "LEGENDARY") {
            item.rarity = ItemRarity::LEGENDARY;
        } else if (rarityStr == "RARE") {
            item.rarity = ItemRarity::RARE;
        } else {
            item.rarity = ItemRarity::COMMON;
        }

        items.append(item);
    }

    qDebug() << "Loaded" << items.size() << "items from database";
    return items;
}

bool DatabaseManager::saveGameState(const QString& playerName, int goldBars, int currentLocation,
                                    const QString& inventoryJson, const QString& logsJson)
{
    QSqlQuery query(m_connection->getDatabase());
    query.prepare("INSERT INTO game_saves (player_name, gold_bars, current_location, inventory, logs) "
                  "VALUES (:player, :gold, :location, :inventory, :logs)");

    query.bindValue(":player", playerName);
    query.bindValue(":gold", goldBars);
    query.bindValue(":location", currentLocation);
    query.bindValue(":inventory", inventoryJson);
    query.bindValue(":logs", logsJson);

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to save game state:" << m_lastError;
        return false;
    }

    qDebug() << "Game state saved for player:" << playerName;
    return true;
}

bool DatabaseManager::loadGameState(const QString& playerName)
{
    QSqlQuery query(m_connection->getDatabase());
    query.prepare("SELECT gold_bars, current_location, inventory, logs FROM game_saves "
                  "WHERE player_name = :player ORDER BY saved_at DESC LIMIT 1");
    query.bindValue(":player", playerName);

    if (!query.exec()) {
        m_lastError = query.lastError().text();
        qCritical() << "Failed to load game state:" << m_lastError;
        return false;
    }

    if (query.next()) {
        qDebug() << "Game state loaded for player:" << playerName;
        qDebug() << "Gold bars:" << query.value(0).toInt();
        qDebug() << "Current location:" << query.value(1).toInt();
        return true;
    }

    qWarning() << "No saved game found for player:" << playerName;
    return false;
}

QString DatabaseManager::getLastError() const
{
    return m_lastError;
}


==DatabaseManager.h==

#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QString>
#include <QVector>
#include <memory>
#include "DatabaseConnection.h"
#include "../core/Types.h"

class DatabaseManager
{
public:
    DatabaseManager();
    ~DatabaseManager();

    bool connect();
    bool isConnected() const;

    QVector<LocationData> loadLocations();
    QVector<RiddleData> loadRiddles();
    QVector<NoteData> loadNotes();
    QVector<ItemData> loadItems();

    bool saveGameState(const QString& playerName, int goldBars, int currentLocation,
                      const QString& inventoryJson, const QString& logsJson);
    bool loadGameState(const QString& playerName);

    QString getLastError() const;

private:
    std::unique_ptr<DatabaseConnection> m_connection;
    QString m_lastError;

    bool isDatabaseInitialized();
    bool loadSqlFile(const QString &filePath);
};

#endif // DATABASEMANAGER_H


==game_database.sql==

-- @language SQLite
DROP TABLE IF EXISTS game_saves;
DROP TABLE IF EXISTS notes;
DROP TABLE IF EXISTS items;
DROP TABLE IF EXISTS riddles;
DROP TABLE IF EXISTS locations;

CREATE TABLE locations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    theme TEXT,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE riddles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    difficulty INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content TEXT NOT NULL,
    location_id INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (location_id) REFERENCES locations(id)
);

CREATE TABLE items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL CHECK(type IN ('GOLD_KEY', 'SILVER_KEY')),
    name TEXT,
    description TEXT,
    rarity TEXT DEFAULT 'COMMON'
);

CREATE TABLE game_saves (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    player_name TEXT,
    gold_bars INTEGER DEFAULT 0,
    current_location INTEGER DEFAULT 0,
    inventory TEXT,
    logs TEXT,
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO locations (name, theme, description) VALUES
('Ancient Castle', 'Gothic', 'Dark corridors'),
('Order Dungeon', 'Mystic', 'Sacred underground'),
('Forgotten City', 'Decay', 'City ruins'),
('Shadow Forest', 'Nature', 'Ancient forest'),
('Crystal Palace', 'Fantasy', 'Sparkling palace');

INSERT INTO riddles (question, answer, difficulty) VALUES
('What has cities but no houses?', 'map', 1),
('I am invisible but everyone feels me?', 'wind', 1),
('The more you take, the more you leave?', 'steps', 2),
('What animal has legs on its back?', 'donkey', 2),
('I speak without a mouth?', 'echo', 2);

INSERT INTO items (type, name, description, rarity) VALUES
('SILVER_KEY', 'Silver Key', 'Old key', 'COMMON'),
('GOLD_KEY', 'Gold Key', 'Heavy key', 'RARE'),
('SILVER_KEY', 'Ancient Key', 'Engraved key', 'COMMON'),
('GOLD_KEY', 'Royal Key', 'Key with emblem', 'LEGENDARY');

INSERT INTO notes (content, location_id) VALUES
('Beware of shadows...', 1),
('Gold is heavier.', 4),
('Three left two right...', 3),
('He lied about exit.', 2),
('Key was swallowed.', 5),
('Silence is your friend.', 1),
('Do not look in mirrors.', 5),
('Code 4-2-...', 3),
('They are watching.', 2),
('Run.', 4);
